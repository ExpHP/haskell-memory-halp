* haskell-halp

memory errors trying to parse a big yaml file with the `yaml` package

** Running

Watch a 4 MB test file take up 80 MB of "pinned" memory (bytestrings?):

#+BEGIN_SRC bash
    ./makeit 10 90 30
#+END_SRC

[[https://rawgit.com/ExpHP/haskell-memory-halp/master/saved/attempt1.svg]]

Larger numbers make a bigger file.

** Files

- app/Attempt1 ::
  *(rendered pointless by Attempt3)*
  attempt using plain data structures that map directly to the YAML.
  (originally handcoded, this has now been rewritten to use Aeson's
  TemplateHaskell functions, with no discernable effect on the outcome)
- app/Attempt2 ::
  *(rendered pointless by Attempt3)*
  attempt using a fromJSON implementation that extracts only the data I want.
- app/Attempt3 ::
  I write the trivial parser ~Value -> Parser Value~, and discover that
  *the entire cost lies in constructing the input ~Value~.*
  AFAICT this renders the entire higher-level API of Aeson completely useless.

  Shit.
- app/Attempt4 ::
  I try a streaming approach which uses [[https://hackage.haskell.org/package/yaml-0.8.22/docs/Text-Libyaml.html][Text.Libyaml]] and [[https://hackage.haskell.org/package/conduit-parse-0.1.2.0/docs/Data-Conduit-Parser.html][Data.Conduit.Parser]]
  to parse the desired object directly out of the Libyaml event stream,
  with no intervening Value representation.

  Things are going great, by which I mean OHGODSOMEBODYHELPME
- other-src/SharedJunk.hs ::
  debugging harness providing a default main.
  Nothing in here ought to matter.

** Other things I tried:

 * replacing ~ByteString.readFile~ and ~Yaml.decodeEither~ with
   ~Yaml.decodeFileEither~...
