* haskell-halp

memory errors trying to parse a big yaml file with the `yaml` package

** Status

I have *identified the source* of the high memory usage:  the initial construction of an Aeson Value.

Unfortunately, this initial Value seems to be central to pretty much the entire Aeson API, so *I'm now trying to work around it with streaming APIs.*  This is not fun.

There currently appears to be a *[[https://github.com/ExpHP/haskell-memory-halp/blob/master/app/Attempt4.hs#L269-L282][single missing piece]]* before I can finally test what I've written:

#+BEGIN_SRC haskell
limitNode :: ConduitParser Event m a -> ConduitParser Event m a
limitNode cont = error "TODO"
#+END_SRC haskell

It should take a continuation parser of type [[https://hackage.haskell.org/package/conduit-parse-0.1.2.0/docs/Data-Conduit-Parser.html][ConduitParser]] and supply it with the events of exactly one [[http://pyyaml.org/wiki/LibYAML#Events][node]] from the [[https://hackage.haskell.org/package/yaml-0.8.22/docs/Text-Libyaml.html][Libyaml stream]] (leaving the rest of the stream after this node undisturbed), serving a purpose analogous to ~takeExactlyC~.

Notice that:

 * ConduitParser is a wrapper around ~Sink~ (hence: no piping mechanism)
 * ...yet cannot (?) be constructed from one (hence: can't do e.g. ~ConduitParser $ a .| b~)
 
And for these reasons I'm beginning to think that these "key missing functions" are impossible...

** Running

Watch a 4 MB test file take up 80 MB of "pinned" memory (bytestrings?):

#+BEGIN_SRC bash
    ./makeit 10 90 30
#+END_SRC

[[https://rawgit.com/ExpHP/haskell-memory-halp/master/saved/attempt1.svg]]

Larger numbers make a bigger file.

** Files

- app/Attempt1 ::
  *(rendered pointless by Attempt3)*
  attempt using plain data structures that map directly to the YAML.
  (originally handcoded, this has now been rewritten to use Aeson's
  TemplateHaskell functions, with no discernable effect on the outcome)
- app/Attempt2 ::
  *(rendered pointless by Attempt3)*
  attempt using a fromJSON implementation that extracts only the data I want.
- app/Attempt3 ::
  I write the trivial parser ~Value -> Parser Value~, and discover that
  *the entire cost lies in constructing the input ~Value~.*
  AFAICT this renders the entire higher-level API of Aeson completely useless.

  Shit.
- app/Attempt4 ::
  I try a streaming approach which uses [[https://hackage.haskell.org/package/yaml-0.8.22/docs/Text-Libyaml.html][Text.Libyaml]] and [[https://hackage.haskell.org/package/conduit-parse-0.1.2.0/docs/Data-Conduit-Parser.html][Data.Conduit.Parser]]
  to parse the desired object directly out of the Libyaml event stream,
  with no intervening Value representation.

  Things are going great, by which I mean OHGODSOMEBODYHELPME
- other-src/SharedJunk.hs ::
  debugging harness providing a default main.
  Nothing in here ought to matter.

** Other things I tried:

 * replacing ~ByteString.readFile~ and ~Yaml.decodeEither~ with
   ~Yaml.decodeFileEither~...
